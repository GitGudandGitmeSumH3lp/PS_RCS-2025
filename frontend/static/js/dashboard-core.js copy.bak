/*
 * PS_RCS_PROJECT
 * Copyright (c) 2026. All rights reserved.
 * File: frontend/static/js/dashboard-core.js
 * Description: Core logic for the service dashboard, handling state, themes, and API polling.
 */

class DashboardCore {
    constructor() {
        this.currentTheme = 'dark';
        this.moduleStates = {};
        this.pollIntervalId = null;
        this.visionPanel = null;
        this.ocrPanel = null;

        this.THEME_CONFIG = {
            DARK: 'dark',
            LIGHT: 'light',
            STORAGE_KEY: 'ps_rcs_theme_preference'
        };

        this.MODULE_STATUS_TYPES = {
            ONLINE: 'online',
            OFFLINE: 'offline',
            STANDBY: 'standby'
        };

        this.VALID_MODULES = ['motor', 'camera', 'system'];
    }

    init() {
        const savedTheme = this.loadThemePreference();
        this.currentTheme = savedTheme;
        document.documentElement.setAttribute('data-theme', savedTheme);
        document.body.setAttribute('data-theme', savedTheme);

        const themeToggle = document.getElementById('theme-toggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => this.toggleTheme());
        }

        this.VALID_MODULES.forEach(module => {
            const element = document.getElementById(`${module}-status`);
            if (element) {
                const status = element.getAttribute('data-status');
                this.moduleStates[module] = status;
            }
        });

        this.setupModalInteractions();
        this._startStatusPolling();
        
        this.visionPanel = new VisionPanel();
        this.ocrPanel = new OCRPanel();
    }

    toggleTheme() {
        this.currentTheme = this.currentTheme === this.THEME_CONFIG.DARK 
            ? this.THEME_CONFIG.LIGHT 
            : this.THEME_CONFIG.DARK;
        
        document.documentElement.setAttribute('data-theme', this.currentTheme);
        document.body.setAttribute('data-theme', this.currentTheme);
        
        this.saveThemePreference(this.currentTheme);
        
        document.dispatchEvent(new CustomEvent('themeChanged', {
            detail: { theme: this.currentTheme }
        }));
    }

    loadThemePreference() {
        const saved = localStorage.getItem(this.THEME_CONFIG.STORAGE_KEY);
        return (saved === this.THEME_CONFIG.DARK || saved === this.THEME_CONFIG.LIGHT)
            ? saved
            : this.THEME_CONFIG.DARK;
    }

    saveThemePreference(theme) {
        if (theme === this.THEME_CONFIG.DARK || theme === this.THEME_CONFIG.LIGHT) {
            localStorage.setItem(this.THEME_CONFIG.STORAGE_KEY, theme);
        }
    }

    updateModuleStatus(moduleName, status, displayText) {
        if (!this.VALID_MODULES.includes(moduleName)) return false;
        
        const validStatuses = Object.values(this.MODULE_STATUS_TYPES);
        if (!validStatuses.includes(status)) return false;

        const elementId = `${moduleName}-status`;
        const element = document.getElementById(elementId);

        if (!element) return false;

        element.setAttribute('data-status', status);
        
        if (!element.classList.contains('status-indicator')) {
            element.textContent = displayText || status.toUpperCase();
        }
        
        this.moduleStates[moduleName] = status;
        
        if (moduleName === 'camera' && this.visionPanel) {
            this.visionPanel.updateStatusIndicator(status === 'online');
        }
        
        return true;
    }

    setupModalInteractions() {
        this._setupCardClicks();
        this._setupModalClosers();
        this._setupControls();
    }
    
    _setupCardClicks() {
        const cards = document.querySelectorAll('.linear-card.clickable');
        cards.forEach(card => {
            card.addEventListener('click', () => {
                if (card.id === 'card-vision-preview') {
                    this.visionPanel.openModal();
                } else if (card.id === 'control-card') {
                    const modal = document.getElementById('controlModal');
                    if (modal) modal.showModal();
                } else if (card.id === 'ocr-scanner-card') {
                    this.ocrPanel.openModal();
                }
            });

            card.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    card.click();
                }
            });
        });
    }

    _setupModalClosers() {
        const modals = document.querySelectorAll('.linear-modal');
        const closeButtons = document.querySelectorAll('.btn-ghost');
        
        closeButtons.forEach(button => {
            button.addEventListener('click', () => {
                const modal = button.closest('.linear-modal');
                if (modal) modal.close();
            });
        });

        modals.forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.close();
            });
            modal.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') modal.close();
            });
        });
    }
    
    _setupControls() {
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');
        
        if (speedSlider && speedValue) {
            const updateGradient = (val) => {
                 const gradient = `linear-gradient(to right, var(--accent-primary) 0%, var(--accent-primary) ${val}%, var(--border-light) ${val}%, var(--border-light) 100%)`;
                 speedSlider.style.background = gradient;
                 speedValue.textContent = `${val}%`;
            };
            
            speedSlider.addEventListener('input', () => updateGradient(speedSlider.value));
            updateGradient(speedSlider.value);
        }

        const dirButtons = document.querySelectorAll('.dir-btn');
        dirButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const direction = btn.getAttribute('data-dir');
                fetch('/api/motor/control', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: direction, speed: speedSlider ? parseInt(speedSlider.value) : 150 })
                }).catch(console.error);
            });
        });

        const applyButton = document.getElementById('apply-controls');
        if (applyButton) {
            applyButton.addEventListener('click', () => {
                applyButton.textContent = 'Applied!';
                applyButton.style.backgroundColor = 'var(--accent-success)';
                setTimeout(() => {
                    applyButton.textContent = 'Apply';
                    applyButton.style.backgroundColor = '';
                }, 2000);
            });
        }
    }

    _startStatusPolling() {
        if (this.pollIntervalId) this.stopStatusPolling();

        const poll = () => {
            fetch('/api/status')
                .then(res => res.ok ? res.json() : Promise.reject(`HTTP ${res.status}`))
                .then(data => this._processStatusUpdate(data))
                .catch(error => {
                    console.error('Status poll failed:', error);
                    this._updateConnectionIndicator(false);
                });
        };

        poll();
        this.pollIntervalId = setInterval(poll, 2000);
    }

    stopStatusPolling() {
        if (this.pollIntervalId) {
            clearInterval(this.pollIntervalId);
            this.pollIntervalId = null;
        }
    }

    _processStatusUpdate(statusData) {
        if (!statusData || typeof statusData !== 'object') return;

        const cameraOnline = statusData.camera_connected || false;
        const motorOnline = statusData.motor_connected || false;
        const systemOnline = statusData.lidar_connected || false;

        this.updateModuleStatus('camera', cameraOnline ? 'online' : 'offline');
        this.updateModuleStatus('motor', motorOnline ? 'online' : 'offline');
        this.updateModuleStatus('system', systemOnline ? 'online' : 'offline');

        if (typeof statusData.battery_voltage === 'number') {
            this._updateBatteryDisplay(statusData.battery_voltage);
        }

        this._updateConnectionIndicator(cameraOnline || motorOnline || systemOnline);
    }

    _updateConnectionIndicator(isConnected) {
        const indicator = document.getElementById('connection-indicator');
        if (!indicator) return;

        if (isConnected) {
            indicator.setAttribute('data-connected', 'true');
            indicator.textContent = 'CONN: ONLINE';
        } else {
            indicator.setAttribute('data-connected', 'false');
            indicator.textContent = 'CONN: OFFLINE';
        }
    }

    _updateBatteryDisplay(voltage) {
        const display = document.getElementById('battery-display');
        if (!display) return;

        display.setAttribute('data-voltage', voltage.toFixed(1));
        display.textContent = `${voltage.toFixed(1)}V`;
    }
}

class VisionPanel {
    constructor() {
        this.elements = {};
        this.streamActive = false;
        this.scanInProgress = false;
        this._initializeElements();
        this._initializeEventListeners();
    }

    _initializeElements() {
        const ids = [
            'card-vision-preview', 'modal-vision', 'vision-stream',
            'btn-vision-scan', 'btn-vision-close', 'btn-scan-label',
            'btn-capture-photo', 'capture-preview', 'capture-thumbnail',
            'download-link', 'btn-scan-capture', 'close-preview'
        ];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        this.elements['.results-data'] = document.querySelector('.results-data');
    }

    _initializeEventListeners() {
        if (this.elements['btn-vision-close']) {
            this.elements['btn-vision-close'].addEventListener('click', () => this.closeModal());
        }
        
        if (this.elements['close-preview']) {
            this.elements['close-preview'].addEventListener('click', () => this._hideCapturePreview());
        }

        const scanBtns = [this.elements['btn-vision-scan'], this.elements['btn-scan-label']];
        scanBtns.forEach(btn => {
            if (btn) btn.addEventListener('click', () => this.triggerScan());
        });

        if (this.elements['btn-capture-photo']) {
            this.elements['btn-capture-photo'].addEventListener('click', () => this.capturePhoto());
        }

        if (this.elements['modal-vision']) {
            this.elements['modal-vision'].addEventListener('close', () => this._stopStream());
        }
    }

    openModal() {
        if (this.elements['modal-vision']) {
            this.elements['modal-vision'].showModal();
            this._startStream();
        }
    }

    closeModal() {
        if (this.elements['modal-vision']) {
            this.elements['modal-vision'].close();
        }
    }

    _startStream() {
        const stream = this.elements['vision-stream'];
        if (!stream || this.streamActive) return;

        const errorOverlay = document.querySelector('.error-state');
        if (errorOverlay) {
            errorOverlay.classList.add('hidden');
        }

        const src = stream.getAttribute('data-src');
        if (src) {
            stream.src = `${src}?t=${Date.now()}`;
            this.streamActive = true;
            stream.onerror = () => this._handleStreamError();
        }
    }

    _stopStream() {
        const stream = this.elements['vision-stream'];
        if (stream) {
            stream.src = '';
            this.streamActive = false;
        }
    }

    _handleStreamError() {
        this.updateStatusIndicator(false);
        const errorState = document.querySelector('.error-state');
        if (errorState) errorState.classList.remove('hidden');
    }

    updateStatusIndicator(isOnline) {
        const card = this.elements['card-vision-preview'];
        if (!card) return;

        const indicator = card.querySelector('.status-indicator');
        const text = card.querySelector('.status-text');

        if (indicator && text) {
            indicator.setAttribute('data-status', isOnline ? 'online' : 'offline');
            text.textContent = isOnline ? 'Online' : 'Offline';
        }
    }

    async capturePhoto() {
        const btn = this.elements['btn-capture-photo'];
        if (btn) btn.disabled = true;

        try {
            const res = await fetch('/api/vision/capture', { method: 'POST' });
            if (!res.ok) throw new Error('Capture failed');
            
            const data = await res.json();
            if (data.success) {
                this._showCapturePreview(data);
            }
        } catch (err) {
            console.error(err);
        } finally {
            if (btn) btn.disabled = false;
        }
    }

    _showCapturePreview(data) {
        const preview = this.elements['capture-preview'];
        const thumb = this.elements['capture-thumbnail'];
        const link = this.elements['download-link'];
        
        if (preview && thumb && link) {
            thumb.src = `${data.download_url}?t=${Date.now()}`;
            link.href = data.download_url;
            link.setAttribute('download', data.filename);
            preview.classList.remove('hidden');
        }
    }
    
    _hideCapturePreview() {
        const preview = this.elements['capture-preview'];
        const thumbnail = this.elements['capture-thumbnail'];

        if (preview) preview.classList.add('hidden');
        if (thumbnail) thumbnail.src = '';
    }

    async triggerScan() {
        if (this.scanInProgress) return;
        this.scanInProgress = true;
        
        try {
            const res = await fetch('/api/vision/scan', { method: 'POST' });
            if (!res.ok) throw new Error('Scan failed');
            
            const data = await res.json();
            if (data.scan_id) {
                await this._pollScanResults(data.scan_id);
            }
        } catch (err) {
            console.error(err);
        } finally {
            this.scanInProgress = false;
        }
    }
    
    async _pollScanResults(scanId) {
        let attempts = 0;
        while (attempts < 30) {
            const res = await fetch(`/api/vision/results/${scanId}`);
            const data = await res.json();
            
            if (data.status === 'completed') {
                this._displayResults(data.data);
                return;
            }
            if (data.status === 'failed') break;
            
            attempts++;
            await new Promise(r => setTimeout(r, 1000));
        }
    }
    
    _displayResults(data) {
        const results = document.getElementById('scan-results-card');
        if (results) {
            results.classList.remove('hidden');
            
            const fields = ['tracking-id', 'order-id', 'rts-code', 'district', 'confidence', 'scan-time'];
            const values = {
                'tracking-id': data.tracking_id,
                'order-id': data.order_id,
                'rts-code': data.rts_code,
                'district': data.district,
                'confidence': data.confidence,
                'scan-time': data.timestamp
            };
            
            fields.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.textContent = values[id] || '-';
            });
        }
    }
}

class OCRPanel {
    constructor() {
        this.elements = {};
        this.activeTab = 'camera';
        this.currentImage = null;
        this.streamActive = false;
        this.streamSrc = '/api/vision/stream';
        
        this._initializeElements();
        this._initializeEventListeners();
    }

    _initializeElements() {
        this.elements = {
            modal: document.getElementById('ocr-scanner-modal'),
            closeBtn: document.getElementById('btn-ocr-close'),
            tabs: {
                camera: document.getElementById('btn-tab-camera'),
                upload: document.getElementById('btn-tab-upload'),
                paste: document.getElementById('btn-tab-paste')
            },
            panels: {
                camera: document.getElementById('tab-camera'),
                upload: document.getElementById('tab-upload'),
                paste: document.getElementById('tab-paste')
            },
            stream: document.getElementById('ocr-stream'),
            streamOverlay: document.querySelector('#tab-camera .stream-overlay'),
            errorState: document.querySelector('#tab-camera .error-state'),
            captureBtn: document.getElementById('btn-ocr-capture'),
            fileInput: document.getElementById('ocr-file-input'),
            fileDropzone: document.querySelector('.file-dropzone'),
            uploadPreview: document.getElementById('upload-preview-container'),
            uploadPreviewImg: document.getElementById('upload-preview-img'),
            clearUploadBtn: document.getElementById('btn-clear-upload'),
            pasteArea: document.getElementById('paste-dropzone'),
            pastePreview: document.getElementById('paste-preview-container'),
            pastePreviewImg: document.getElementById('paste-preview-img'),
            clearPasteBtn: document.getElementById('btn-clear-paste'),
            analyzeBtn: document.getElementById('btn-analyze'),
            resultsPanel: document.getElementById('ocr-results-panel')
        };

        if (!this.elements.modal) {
            console.warn('[OCRPanel] Modal element not found');
        }
    }

    _initializeEventListeners() {
        const card = document.getElementById('ocr-scanner-card');
        if (card) {
            card.addEventListener('click', () => this.openModal());
        }

        if (this.elements.closeBtn) {
            this.elements.closeBtn.addEventListener('click', () => this.closeModal());
        }

        Object.entries(this.elements.tabs).forEach(([tabId, btn]) => {
            if (btn) {
                btn.addEventListener('click', () => this.switchTab(tabId));
                
                btn.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                        e.preventDefault();
                        const tabs = Object.keys(this.elements.tabs);
                        const currentIndex = tabs.indexOf(tabId);
                        const nextIndex = e.key === 'ArrowRight'
                            ? (currentIndex + 1) % tabs.length
                            : (currentIndex - 1 + tabs.length) % tabs.length;
                        this.switchTab(tabs[nextIndex]);
                        this.elements.tabs[tabs[nextIndex]].focus();
                    }
                });
            }
        });

        if (this.elements.captureBtn) {
            this.elements.captureBtn.addEventListener('click', () => this._captureFrame());
        }

        if (this.elements.fileInput) {
            this.elements.fileInput.addEventListener('change', (e) => this._handleFileSelect(e));
        }

        if (this.elements.fileDropzone) {
            ['dragenter', 'dragover'].forEach(event => {
                this.elements.fileDropzone.addEventListener(event, (e) => {
                    e.preventDefault();
                    this.elements.fileDropzone.classList.add('drag-over');
                });
            });

            ['dragleave', 'drop'].forEach(event => {
                this.elements.fileDropzone.addEventListener(event, (e) => {
                    e.preventDefault();
                    this.elements.fileDropzone.classList.remove('drag-over');
                });
            });

            this.elements.fileDropzone.addEventListener('drop', (e) => this._handleDrop(e));
        }

        if (this.elements.pasteArea) {
            this.elements.pasteArea.addEventListener('paste', (e) => this._handlePaste(e));
            
            ['dragenter', 'dragover'].forEach(event => {
                this.elements.pasteArea.addEventListener(event, (e) => {
                    e.preventDefault();
                    this.elements.pasteArea.classList.add('drag-over');
                });
            });

            ['dragleave', 'drop'].forEach(event => {
                this.elements.pasteArea.addEventListener(event, (e) => {
                    e.preventDefault();
                    this.elements.pasteArea.classList.remove('drag-over');
                });
            });

            this.elements.pasteArea.addEventListener('drop', (e) => this._handleDrop(e));
        }

        if (this.elements.clearUploadBtn) {
            this.elements.clearUploadBtn.addEventListener('click', () => this._clearPreview());
        }
        if (this.elements.clearPasteBtn) {
            this.elements.clearPasteBtn.addEventListener('click', () => this._clearPreview());
        }

        if (this.elements.analyzeBtn) {
            this.elements.analyzeBtn.addEventListener('click', () => this.analyzeDocument());
        }

        document.querySelectorAll('.btn-copy').forEach(btn => {
            btn.addEventListener('click', () => {
                const fieldId = btn.getAttribute('data-field');
                this._copyToClipboard(fieldId);
            });
        });
    }

    switchTab(tabId) {
        if (!['camera', 'upload', 'paste'].includes(tabId)) {
            console.warn(`[OCRPanel] Invalid tab ID: ${tabId}`);
            return;
        }

        this.activeTab = tabId;

        Object.entries(this.elements.tabs).forEach(([id, btn]) => {
            if (btn) {
                const isActive = id === tabId;
                btn.setAttribute('aria-selected', isActive);
                btn.setAttribute('tabindex', isActive ? '0' : '-1');
            }
        });

        Object.entries(this.elements.panels).forEach(([id, panel]) => {
            if (panel) {
                if (id === tabId) {
                    panel.classList.remove('hidden');
                } else {
                    panel.classList.add('hidden');
                }
            }
        });

        if (tabId === 'camera') {
            this._startCameraStream();
        } else {
            this._stopCameraStream();
        }

        this.currentImage = null;
        if (this.elements.analyzeBtn) {
            this.elements.analyzeBtn.disabled = true;
        }
    }

    _startCameraStream() {
        if (this.streamActive || !this.elements.stream) return;

        if (this.elements.errorState) {
            this.elements.errorState.classList.add('hidden');
        }

        if (this.elements.streamOverlay) {
            this.elements.streamOverlay.classList.remove('hidden');
        }

        this.elements.stream.src = this.streamSrc;
        this.streamActive = true;

        this.elements.stream.onload = () => {
            if (this.elements.streamOverlay) {
                this.elements.streamOverlay.classList.add('hidden');
            }
        };

        this.elements.stream.onerror = () => {
            if (this.elements.streamOverlay) {
                this.elements.streamOverlay.classList.add('hidden');
            }
            if (this.elements.errorState) {
                this.elements.errorState.classList.remove('hidden');
            }
            this.streamActive = false;
        };
    }

    _stopCameraStream() {
        if (!this.streamActive || !this.elements.stream) return;

        this.elements.stream.src = '';
        this.streamActive = false;

        if (this.elements.streamOverlay) {
            this.elements.streamOverlay.classList.remove('hidden');
        }
    }

    async _handlePaste(event) {
        const items = event.clipboardData?.items;
        if (!items) {
            this._showToast('No clipboard data found', 'error');
            return;
        }

        for (const item of items) {
            if (item.type.startsWith('image/')) {
                const file = item.getAsFile();
                if (file && this._validateImageFile(file)) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        this.currentImage = e.target.result;
                        this._showPreview(e.target.result);
                        if (this.elements.analyzeBtn) {
                            this.elements.analyzeBtn.disabled = false;
                        }
                    };
                    reader.readAsDataURL(file);
                }
                return;
            }
        }

        this._showToast('No image data found in clipboard', 'error');
    }

    _handleDrop(event) {
        const files = event.dataTransfer?.files;
        if (!files || files.length === 0) return;

        const file = files[0];
        if (this._validateImageFile(file)) {
            const reader = new FileReader();
            reader.onload = (e) => {
                this.currentImage = e.target.result;
                this._showPreview(e.target.result);
                if (this.elements.analyzeBtn) {
                    this.elements.analyzeBtn.disabled = false;
                }
            };
            reader.readAsDataURL(file);
        }
    }

    _handleFileSelect(event) {
        const files = event.target.files;
        if (!files || files.length === 0) return;

        const file = files[0];
        if (this._validateImageFile(file)) {
            const reader = new FileReader();
            reader.onload = (e) => {
                this.currentImage = e.target.result;
                this._showPreview(e.target.result);
                if (this.elements.analyzeBtn) {
                    this.elements.analyzeBtn.disabled = false;
                }
            };
            reader.readAsDataURL(file);
        }
    }

    _validateImageFile(file) {
        const MAX_SIZE = 5 * 1024 * 1024;
        const VALID_TYPES = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];

        if (!VALID_TYPES.includes(file.type)) {
            this._showToast('Invalid file type. Use PNG, JPG, or WEBP', 'error');
            return false;
        }

        if (file.size > MAX_SIZE) {
            this._showToast('File too large. Maximum size is 5MB', 'error');
            return false;
        }

        return true;
    }

    _showPreview(imageDataUrl) {
        let container, img;

        if (this.activeTab === 'upload') {
            container = this.elements.uploadPreview;
            img = this.elements.uploadPreviewImg;
            if (this.elements.fileDropzone) {
                this.elements.fileDropzone.style.display = 'none';
            }
        } else if (this.activeTab === 'paste') {
            container = this.elements.pastePreview;
            img = this.elements.pastePreviewImg;
            if (this.elements.pasteArea) {
                this.elements.pasteArea.style.display = 'none';
            }
        }

        if (container && img) {
            img.src = imageDataUrl;
            container.classList.remove('hidden');
        }
    }

    _clearPreview() {
        this.currentImage = null;

        if (this.activeTab === 'upload') {
            if (this.elements.uploadPreview) {
                this.elements.uploadPreview.classList.add('hidden');
            }
            if (this.elements.uploadPreviewImg) {
                this.elements.uploadPreviewImg.src = '';
            }
            if (this.elements.fileDropzone) {
                this.elements.fileDropzone.style.display = '';
            }
            if (this.elements.fileInput) {
                this.elements.fileInput.value = '';
            }
        } else if (this.activeTab === 'paste') {
            if (this.elements.pastePreview) {
                this.elements.pastePreview.classList.add('hidden');
            }
            if (this.elements.pastePreviewImg) {
                this.elements.pastePreviewImg.src = '';
            }
            if (this.elements.pasteArea) {
                this.elements.pasteArea.style.display = '';
            }
        }

        if (this.elements.analyzeBtn) {
            this.elements.analyzeBtn.disabled = true;
        }
    }

    async _captureFrame() {
        try {
            const response = await fetch('/api/vision/capture', {
                method: 'POST'
            });

            if (!response.ok) {
                throw new Error('Capture failed');
            }

            const data = await response.json();
            
            this.currentImage = data.download_url;
            
            if (this.elements.analyzeBtn) {
                this.elements.analyzeBtn.disabled = false;
            }

            this._showToast('Frame captured successfully', 'success');
        } catch (error) {
            console.error('[OCRPanel] Capture error:', error);
            this._showToast('Failed to capture frame', 'error');
        }
    }

    async analyzeDocument() {
        if (!this.currentImage) {
            this._showToast('No image to analyze', 'error');
            return;
        }

        const btnText = this.elements.analyzeBtn.querySelector('.btn-text');
        const btnSpinner = this.elements.analyzeBtn.querySelector('.btn-spinner');
        
        if (btnText) btnText.classList.add('hidden');
        if (btnSpinner) btnSpinner.classList.remove('hidden');
        this.elements.analyzeBtn.disabled = true;

        try {
            let response;

            if (this.activeTab === 'camera') {
                const imageResponse = await fetch(this.currentImage);
                const blob = await imageResponse.blob();
                const formData = new FormData();
                formData.append('image', blob, 'capture.jpg');

                response = await fetch('/api/ocr/analyze', {
                    method: 'POST',
                    body: formData
                });
            } else {
                response = await fetch('/api/ocr/analyze', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image_data: this.currentImage.split(',')[1]
                    })
                });
            }

            if (!response.ok) {
                throw new Error('Analysis failed');
            }

            const result = await response.json();
            
            if (result.status === 'processing') {
                await this._pollForResults(result.scan_id);
            } else {
                this._displayResults(result);
            }
        } catch (error) {
            console.error('[OCRPanel] Analysis error:', error);
            this._showToast('Analysis failed. Please try again', 'error');
        } finally {
            if (btnText) btnText.classList.remove('hidden');
            if (btnSpinner) btnSpinner.classList.add('hidden');
            this.elements.analyzeBtn.disabled = false;
        }
    }

    async _pollForResults(scanId, maxAttempts = 20) {
        for (let i = 0; i < maxAttempts; i++) {
            await new Promise(resolve => setTimeout(resolve, 500));

            const response = await fetch(`/api/vision/results/${scanId}`);
            const data = await response.json();

            if (data.status === 'completed') {
                this._displayResults(data.data);
                return;
            }
        }

        this._showToast('Analysis timeout. Please try again', 'error');
    }

    _displayResults(data) {
        if (!this.elements.resultsPanel || !data) return;
        console.log('[OCR Raw Data]:', data);
        
        const getField = (snakeCase, camelCase) => {
            const value = data[snakeCase] ?? data[camelCase] ?? null;
            return value && value.trim() !== '' ? value.trim() : null;
        };
        
        const tracking = getField('tracking_id', 'trackingId');
        const order = getField('order_id', 'orderId');
        const rts = getField('rts_code', 'rtsCode');
        const district = getField('district', 'district');
        const confidence = data.confidence ? parseFloat(data.confidence) : 0;
        const timestamp = data.timestamp || data.scan_time;
        
        const coreFields = [tracking, order, rts, district];
        const isEmpty = coreFields.every(field => !field);
        
        const confidenceBadge = this.elements.resultsPanel.querySelector('.confidence-badge');
        const confidenceText = document.getElementById('confidence-value');
        if (confidenceBadge && confidenceText) {
            let level = 'low';
            if (confidence >= 0.85) level = 'high';
            else if (confidence >= 0.7) level = 'medium';
            confidenceBadge.setAttribute('data-level', level);
            confidenceText.textContent = `${(confidence * 100).toFixed(0)}%`;
        }
        
        const fields = {
            'result-tracking-id': tracking,
            'result-order-id': order,
            'result-rts-code': rts,
            'result-district': district,
            'result-timestamp': timestamp ? (() => {
                try {
                    const date = new Date(timestamp);
                    return isNaN(date.getTime()) ? null : date.toLocaleString();
                } catch {
                    return null;
                }
            })() : null
        };
        
        Object.entries(fields).forEach(([id, value]) => {
            const element = document.getElementById(id);
            if (element) {
                const valueSpan = element.querySelector('.data-value');
                if (valueSpan) {
                    valueSpan.textContent = value ?? '-';
                }
            }
        });
        
        this.elements.resultsPanel.classList.remove('hidden');
        this.elements.resultsPanel.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        
        if (isEmpty) {
            this._showToast('No text detected in image', 'warning');
        } else if (confidence < 0.5) {
            this._showToast('Low confidence results - verify accuracy', 'warning');
        } else if (confidence >= 0.85) {
            this._showToast('High confidence analysis complete', 'success');
        } else {
            this._showToast('Analysis complete', 'success');
        }
    }

    _copyToClipboard(fieldId) {
        const element = document.getElementById(`result-${fieldId}`);
        if (!element) return;

        const valueSpan = element.querySelector('.data-value');
        if (!valueSpan) return;

        const text = valueSpan.textContent;
        if (text === '-') return;

        navigator.clipboard.writeText(text).then(() => {
            this._showToast('Copied to clipboard', 'success');
        }).catch(() => {
            this._showToast('Failed to copy', 'error');
        });
    }

    _showToast(message, type = 'info') {
        console.log(`[OCRPanel Toast - ${type}]:`, message);
    }

    openModal() {
        if (!this.elements.modal) return;

        this.elements.modal.showModal();
        
        this.switchTab('camera');
        
        if (this.elements.resultsPanel) {
            this.elements.resultsPanel.classList.add('hidden');
        }
    }

    closeModal() {
        if (!this.elements.modal) return;

        this._stopCameraStream();
        
        this._clearPreview();
        
        this.elements.modal.close();
    }
}

document.addEventListener('DOMContentLoaded', () => {
    const dashboard = new DashboardCore();
    dashboard.init();
});